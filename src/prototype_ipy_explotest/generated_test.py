import ast
from dataclasses import dataclass


class PyTestFixture:
    """
    Represents a PyTest fixture - a provider for a parameter in our FUT.
    """
    depends_on: list['PyTestFixture']  # the fixtures this test depends on
    # TODO: figure out if and how to distinguish between param vs. non-para
    for_var: str  # for which variable is this for? is it a param?
    stmts: list[ast.stmt | ast.expr]

    def __init__(self, for_var):
        self.depends_on = []
        self.for_var = for_var
        self.stmts = []

    def add_depends(self, fixture):
        self.depends_on.append(fixture)

    @property
    def ast_node(self, function_name: str | None = None) -> ast.FunctionDef:
        function_name = f'generated_{self.for_var}' if function_name is None else function_name
        assert function_name is not None
        func_def = ast.FunctionDef(name=function_name, args=ast.arguments(
            args=[ast.arg(fixture.ast_node.name) for fixture in self.depends_on]), body=self.stmts, decorator_list=[
            ast.Attribute(value=ast.Name(id='pytest', ctx=ast.Load()), attr='fixture',
                          ctx=ast.Load())])

        func_def = ast.fix_missing_locations(func_def)  # adds linenos to support unparsing into real code.
        return func_def

    def add_node(self, stmt: ast.stmt | ast.expr) -> None:
        self.stmts.append(stmt)

    def __str__(self):
        """
        Returns itself a writeable string of code.
        :return: The code for this fixture. Should be syntactically correct.
        """
        return ast.unparse(self.ast_node)


@dataclass
class GeneratedTest:
    """
    Represents a test generated by explotest.
    """
    definitions: list[ast.FunctionDef]
    code_imports: set[ast.Import | ast.ImportFrom]
    for_func_name: str
    arrange_phase: list[PyTestFixture]
    act_phase: list[ast.Assign]  # hmm... is this right?
    assert_phase: list[ast.Assert]  # hmm... is this right?

    # TODO: better type annotations
    # TODO: handle import relocation
    # def __init__(self):
    #     self.definitions = []
    #     self.code_imports
    #     self.arrange_phase = []
    #     self.act_phase = []
    #     self.assert_phase = []

    @property
    def ast_node(self) -> ast.Module:
        """
        Returns the generated test as an ast.Module
        """
        statements = []

        for im in self.imports:
            statements.append(im)

        for fixture in self.arrange_phase:
            statements.append(fixture.ast_node)

        for defn in self.definitions:
            statements.append(defn)

        statements.append(self.test_function)

        return ast.fix_missing_locations(ast.Module(body=statements))

    @property
    def test_function(self) -> ast.FunctionDef:  # right now, test_function requests all the fixtures.
        generated_fn = ast.FunctionDef(name=f'test_{self.for_func_name}', args=ast.arguments(
            args=[ast.arg(arg=fixture.ast_node.name) for fixture in self.arrange_phase]), body=self.act_phase)
        generated_fn = ast.fix_missing_locations(generated_fn)
        return generated_fn

    @property
    def imports(self) -> set[ast.Import | ast.ImportFrom]:
        return {ast.Import(names=[ast.alias(name='pytest')]),
                ast.Import(names=[ast.alias(name='dill')])} | self.code_imports

    def __str__(self):
        """
        Returns the test as a writeable (to disk) and syntactically valid test.
        """
        return ast.unparse(ast.fix_missing_locations(self.ast_node))
